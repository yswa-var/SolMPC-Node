package main

import (
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"encoding/csv"
	"encoding/hex"
	"fmt"
	"math/big"
	"os"
	"sync"
	"sync/atomic"
	mpc "teddsa/eddsa"
	"time"

	"github.com/bnb-chain/tss-lib/v2/tss"

	"go.uber.org/zap"
)

const threshold = 1

type parties []*mpc.Party

func (parties parties) numericIDs() []uint16 {
	var res []uint16
	for _, p := range parties {
		res = append(res, uint16(big.NewInt(0).SetBytes(p.Id.Key).Uint64()))
	}

	return res
}

// init initializes the parties with the given senders.
func (parties parties) init(senders []mpc.Sender) {
	// Initialize each party with the numeric IDs of all parties, the threshold, and the corresponding sender function.
	for i, p := range parties {
		p.Init(parties.numericIDs(), threshold, senders[i])
	}
}

// setShareData sets the share data for each party.
func (parties parties) setShareData(shareData [][]byte) {
	// Set the share data for each party.
	for i, p := range parties {
		p.SetShareData(shareData[i])
	}
}

// sign signs the given message using each party's private key.
func (parties parties) sign(msg []byte) ([][]byte, error) {
	var lock sync.Mutex
	var sigs [][]byte
	var threadSafeError atomic.Value

	var wg sync.WaitGroup
	wg.Add(len(parties))

	for _, p := range parties {
		go func(p *mpc.Party) {
			defer wg.Done()
			// Each party signs the message.
			sig, err := p.Sign(context.Background(), msg)
			if err != nil {
				threadSafeError.Store(err.Error())
				return
			}

			lock.Lock()
			sigs = append(sigs, sig)
			lock.Unlock()
		}(p)
	}

	wg.Wait()

	err := threadSafeError.Load()
	if err != nil {
		return nil, fmt.Errorf(err.(string))
	}

	return sigs, nil
}

// keygen performs the distributed key generation protocol and returns the shares.
func (parties parties) keygen() ([][]byte, error) {
	var lock sync.Mutex
	shares := make([][]byte, len(parties))
	var threadSafeError atomic.Value

	var wg sync.WaitGroup
	wg.Add(len(parties))

	for i, p := range parties {
		go func(p *mpc.Party, i int) {
			defer wg.Done()
			// Each party performs key generation.
			share, err := p.KeyGen(context.Background())
			if err != nil {
				threadSafeError.Store(err.Error())
				return
			}

			lock.Lock()
			shares[i] = share
			lock.Unlock()
		}(p, i)
	}

	wg.Wait()

	err := threadSafeError.Load()
	if err != nil {
		return nil, fmt.Errorf(err.(string))
	}

	return shares, nil
}

// Mapping returns a map of party IDs to party objects.
func (parties parties) Mapping() map[string]*tss.PartyID {
	partyIDMap := make(map[string]*tss.PartyID)
	for _, id := range parties {
		partyIDMap[id.Id.Id] = id.Id
	}
	return partyIDMap
}

//sendMSG( msgBytes []byte, broadcast bool, to uint16)

// generateRandomHash generates a random SHA-256 hash string.
func solanaTransaction() (string, error) {
	// demo function whcih mimics the solana transaction for vaidation.
	// Create a new SHA-256 hash
	hash := sha256.New()

	// Generate a random number.
	randomBytes := make([]byte, 32)
	_, err := rand.Read(randomBytes)
	if err != nil {
		return "", fmt.Errorf("failed to generate random bytes: %v", err)
	}

	// Write the random bytes to the hash.
	_, err = hash.Write(randomBytes)
	if err != nil {
		return "", fmt.Errorf("failed to write to hash: %v", err)
	}

	// Compute the hash and return it as a hex string.
	return hex.EncodeToString(hash.Sum(nil)), nil
}

// Validator represents a validator with an ID and name.
type Validator struct {
	ID   string
	Name string
}

// loadValidators loads the validators from a CSV file.
func loadValidators(filePath string) ([]Validator, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %v", err)
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		return nil, fmt.Errorf("failed to read CSV file: %v", err)
	}

	var validators []Validator
	for _, record := range records {
		if len(record) != 2 {
			return nil, fmt.Errorf("invalid record: %v", record)
		}
		validators = append(validators, Validator{ID: record[0], Name: record[1]})
	}

	return validators, nil
}

func main() {
	validators, err := loadValidators("validators.csv")
	if err != nil {
		fmt.Println("Error loading validators:", err)
	}

	// creating validators from validators.csv
	var parties parties
	for i, v := range validators {
		p := mpc.NewParty(uint16(i+1), logger(v.ID, "main"))
		parties = append(parties, p)
	}
	parties.init(senders(parties))

	println("DKG")

	t1 := time.Now()
	shares, err := parties.keygen()
	if err != nil {
		fmt.Println("Error performing DKG:", err)
	}
	println("DKG completed in", time.Since(t1))

	parties.init(senders(parties))

	parties.setShareData(shares)

	println("Signing message")

	msgToSign := []byte("asdfhjgkhbjhfbvsdlkjfnvslakjsdnalvsjkvnald")
	t1 = time.Now()
	sigs, err := parties.sign(mpc.Digest(msgToSign))
	if err != nil {
		fmt.Println("Error signing message:", err)
	}
	println("Signing completed in", time.Since(t1))

	sigSet := make(map[string]struct{})
	for _, s := range sigs {
		sigSet[string(s)] = struct{}{}
	}
	if len(sigSet) != 1 {
		fmt.Println("Error: Signatures are not identical")
	} else {
		fmt.Println("Signatures are identical")
	}

	pk, err := parties[0].ThresholdPK()
	if err != nil {
		fmt.Println("Error getting threshold public key:", err)
	}

	if !ed25519.Verify(pk, mpc.Digest(msgToSign), sigs[0]) {
		fmt.Println("Signature verification failed")
	} else {
		fmt.Println("Signature verification succeeded")
	}
}

// senders returns a slice of sender functions for each party.
func senders(parties parties) []mpc.Sender {
	var senders []mpc.Sender
	for _, src := range parties {
		src := src
		sender := func(msgBytes []byte, broadcast bool, to uint16) {
			messageSource := uint16(big.NewInt(0).SetBytes(src.Id.Key).Uint64())
			if broadcast {
				for _, dst := range parties {
					if dst.Id == src.Id {
						continue
					}
					dst.OnMsg(msgBytes, messageSource, broadcast)
				}
			} else {
				for _, dst := range parties {
					if to != uint16(big.NewInt(0).SetBytes(dst.Id.Key).Uint64()) {
						continue
					}
					dst.OnMsg(msgBytes, messageSource, broadcast)
				}
			}
		}
		senders = append(senders, sender)
	}
	return senders
}

func getLiveValidators(filename string) []Validator {
	file, err := os.Open(filename)
	if err != nil {
		fmt.Println("Error opening file:", err)
		return nil
	}
	defer file.Close()

	reader := csv.NewReader(file)
	records, err := reader.ReadAll()
	if err != nil {
		fmt.Println("Error reading CSV:", err)
		return nil
	}

	var validators []Validator
	for _, record := range records {
		validators = append(validators, Validator{
			ID:   record[0],
			Name: record[1],
		})
	}
	return validators
}

// logger creates a logger with the given ID and test name.
func logger(id string, testName string) mpc.Logger {
	logConfig := zap.NewDevelopmentConfig()
	logger, _ := logConfig.Build()
	logger = logger.With(zap.String("t", testName)).With(zap.String("id", id))
	return logger.Sugar()
}
